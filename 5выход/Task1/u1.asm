comment ~

ВЫХОД-5 (Задача_1, вспомогательный модуль)

Написать программу из двух модулей. 

В головном модуле описать двойное слово  X (содержимое которого
трактуется как число без знака) и байт Res (содержимое которого
трактуется как число со знаком).  

Во вспомогательном  модуле описать  общедоступную процедуру 
Power2(X,Res) со стандартными соглашениями о связях  (stdcall).
Параметр  X передаётся в процедуру по значению, Res – по ссылке.
Процедура Power2 выполняет проверку 32-битной беззнаковой величины Х:
является ли она степенью двойки, т.е. существует ли такое  k: 
от 0 до 31, что X=2^k. Если да, то процедура записывает в байт Res
показатель k найденной степени двойки, иначе – записывает в байт Res
 -1 (минус!). В процессе своей работы процедура не использует команды
умножения и деления. 

Головной модуль вводит значение переменной Х,  после чего обращается
к внешней процедуре Power2(X,Res)  для проверки числа X.  Затем 
головной модуль выводит в окно консоли полученный в Res ответ. 
На этом работа двухмодульной программы 
завершается.

Подсказка: в двоичном представлении степень двойки выглядит как 
000…010…00, начальная или конечная последовательность нулей может
отсутствовать.  При проверке числа Х рекомендуется использовать 
маску вида 000…010…00 с подвижной единицей (передвигающейся от 
одного края маски до другого), а также команду xor для сравнения
битового представления числа Х  с данной маской (командами cmp и 
sub для сравнения с маской - не пользоваться!).  

Тесты:   
1  -> 0,       2  -> 1,      5  -> -1,      256  -> 8,     65536  -> 16,      
65535  > -1,    1048576  > 20,   2147483648   > 31,     4000000000  > -1   

~

;---------------------------------------------------------------------
;            ВСПОМОГАТЕЛЬНЫЙ МОДУЛЬ (далее ваше решение:)
;---------------------------------------------------------------------
.686
.model flat,stdcall

.data

.code
Power2 proc public
    push EBP
    mov EBP, ESP
    push EAX
    push EBX
    push ECX
    push EDX
    
    mov EBX, [EBP+12]
    xor ECX, ECX
    inc ECX
    mov EDX, 0
@L:    mov EAX, [EBP+8]
    xor EAX, ECX
    jZ @yes
    shl ECX, 1
    inc EDX
    cmp EDX, 32
    jNE @L
    mov EDX, -1
    mov [EBX], DL
    jmp @e
@yes: mov [EBX], DL
@e:    
    pop EDX
    pop ECX
    pop EBX
    pop EAX
    pop EBP
    ret 4*2
    
    
Power2 endp

;---------------------(конец вашего решения)--------------------------
end

